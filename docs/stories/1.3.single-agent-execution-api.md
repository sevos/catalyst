# Story 1.3: Single Agent Execution API

## Status
Approved

## Story
**As a** Rails Developer,
**I want** to implement single agent execution capability that processes agent configuration, input parameters, and user messages to generate system prompts and execute single LLM requests via RubyLLM integration,
**so that** I can execute AI agents with their configured prompts and get results from LLMs synchronously without background processing.

## Acceptance Criteria
1. Agent#execute method accepts user_message as first argument and returns plain text LLM response synchronously
2. Agent#execute method creates an execution record with pending status before processing
3. Execution status is updated to running when processing begins, then to completed/failed based on outcome
4. System prompt is constructed by rendering ERB template from app/ai/prompts/ using agent attributes
5. ERB template resolution follows Rails-like naming convention based on agent class name
6. ERB template inheritance chain is supported for custom agents that inherit from ApplicationAgent
7. RubyLLM integration sends system prompt and user message to configured LLM model
8. Execution record is updated with LLM response, completion status, and interaction tracking before method returns
9. All agent attributes from both delegated type and underlying Catalyst::Agent are captured in execution's input_params field
10. Failed executions update to failed status with error_message, preserve partial results, but execute method raises exception
11. Execute method implementation is organized into logical private methods or concerns for readability

## Tasks / Subtasks

- [ ] Implement Agent#execute method (AC: 1, 2, 3, 8, 9, 10, 11)
  - [ ] Add execute method to Catalyst::Agent model accepting user_message as first argument
  - [ ] Create execution record with pending status and user message
  - [ ] Update execution status to running when processing begins
  - [ ] Capture all agent attributes (delegated type + Catalyst::Agent) in execution's input_params field
  - [ ] Execute synchronously and return plain text LLM response
  - [ ] Update execution record with results and completion status before returning
  - [ ] Handle failures by updating to failed status, capturing error_message, preserving partial results, then raising exception
  - [ ] Organize implementation into logical private methods or concerns for readability
- [ ] Implement prompt template resolution system (AC: 4, 5, 6)
  - [ ] Add Rails-like template resolution based on agent class name
  - [ ] ApplicationAgent resolves to app/ai/prompts/application_agent.md.erb
  - [ ] Marketing::CampaignAgent resolves to app/ai/prompts/marketing/campaign_agent.md.erb
  - [ ] Implement template inheritance chain for custom agents inheriting ApplicationAgent
  - [ ] Pass @agent instance to ERB template for attribute access
  - [ ] Build system prompt from rendered ERB template
- [ ] Integrate RubyLLM for LLM execution (AC: 7, 8)
  - [ ] Use RubyLLM client with agent's model configuration
  - [ ] Send system prompt and user message to LLM
  - [ ] Handle model parameters (temperature, max_tokens, etc.)
  - [ ] Process LLM response as plain text and store results in execution
  - [ ] Update execution status and interaction tracking
- [ ] Add comprehensive testing (AC: 1-11)
  - [ ] Unit tests for Agent#execute method
  - [ ] Test execution status transitions (pending → running → completed/failed)
  - [ ] Test prompt template resolution and inheritance chain
  - [ ] Test prompt construction and template rendering with @agent instance
  - [ ] Test RubyLLM integration and plain text response handling
  - [ ] Test error handling with failed status, error_message capture, and exception raising
  - [ ] Test input_params captures all agent attributes from both delegated type and Catalyst::Agent
  - [ ] Test method organization and code readability

## Dev Notes

**Previous Story Insights:**
- RubyLLM integration completed in Story 1.2.1 with comprehensive configuration
- Agent generation system completed in Story 1.2 with prompt template support in app/ai/prompts/
- Core models established in Story 1.1 with delegated types architecture
- Execution model has chat-like fields: interaction_count, last_interaction_at, input_params
- Prompt templates use ERB with agent attributes accessible

**Data Models:**
- **Catalyst::Agent**: Base model with delegated types, has name, model, model_params, max_iterations [Source: architecture/data-model.md#Primary Models]
- **Catalyst::Execution**: Tracks executions with status enum (pending, running, completed, failed), prompt, result, error_message, started_at, completed_at, interaction_count, last_interaction_at, input_params [Source: architecture/data-model.md#Execution Tracking]
- **ApplicationAgent**: Simple agent type with role, goal, backstory attributes as database columns [Source: architecture/data-model.md#ApplicationAgent]
- **Catalyst::Agentable**: Module providing delegated type behavior with execute method [Source: architecture/data-model.md#Catalyst::Agentable Module]

**API Specifications:**
- **Agent#execute method**: Should accept user_message as first argument, execute synchronously, return plain text LLM response
- **Input parameters**: Capture all agent attributes from both delegated type (e.g., ApplicationAgent) and underlying Catalyst::Agent for comprehensive auditing
- **Execution tracking**: Create execution record with pending status, update to running during processing, then to completed/failed
- **Error handling**: Failed executions update to failed status with error_message, preserve partial results, but execute method raises exception
- **Code organization**: Implement using logical private methods or concerns to maintain readability

**Component Specifications:**
- **Prompt templates**: ERB templates in app/ai/prompts/ directory receiving @agent instance for attribute access [Source: lib/generators/catalyst/agent/templates/agent_prompt.md.erb]
- **Template resolution**: Rails-like naming convention based on agent class name with inheritance chain support
  - ApplicationAgent → app/ai/prompts/application_agent.md.erb
  - Marketing::CampaignAgent → app/ai/prompts/marketing/campaign_agent.md.erb (with ApplicationAgent fallback)
- **Agent attributes**: Database columns like role, goal, backstory accessible as @agent.role, @agent.goal, @agent.backstory in ERB templates
- **RubyLLM integration**: Use configured default model (gpt-4.1-nano) with parameter support, execute synchronously, return plain text response [Source: architecture/execution-flow.md#LLM Integration]
- **Execution tracking**: Create and update execution record synchronously with status transitions (pending → running → completed/failed)
- **Input parameters**: Merge all attributes from both delegated type and underlying Catalyst::Agent for comprehensive auditing
- **Error handling**: Handle RubyLLM exceptions, update execution to failed status with error_message, preserve partial results, then raise exception
- **Code organization**: Use logical private methods or concerns to keep execute method readable and maintainable

**File Locations:**
- Agent model: `/app/models/catalyst/agent.rb`
- Execution model: `/app/models/catalyst/execution.rb`
- Prompt templates: `/app/ai/prompts/*.md.erb` (from Story 1.2)
- Test files: `/test/models/catalyst/`, `/test/jobs/catalyst/`

**Technical Constraints:**
- Ruby on Rails 8 mountable engine architecture
- RubyLLM ~> 1.3 for LLM integration
- SQLite compatibility with JSON serialization
- Minitest framework for testing
- Synchronous execution (no background processing)
- Prompt templates use ERB with @agent instance passed for attribute access
- Input parameters are for execution state capture, not prompt rendering

### Testing
- Test file locations: `/test/models/catalyst/agent_test.rb`
- Test standards: Follow Rails testing conventions with fixtures and mocking
- Testing frameworks: Rails minitest framework
- Specific requirements:
  - Test Agent#execute method creates execution record and returns plain text LLM response
  - Test execution status transitions (pending → running → completed/failed)
  - Test execution stores user message and captures all agent attributes in input_params
  - Test prompt template resolution with Rails-like naming convention
  - Test template inheritance chain for custom agents
  - Test prompt construction uses @agent instance for attribute access
  - Test RubyLLM integration with model parameters and plain text response handling
  - Test error handling: failed status, error_message capture, partial results preservation, exception raising
  - Test interaction tracking (increment_interaction!)
  - Test method organization and code readability patterns
  - Use RubyLLM.test_mode! for testing with mocked responses

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-07-11 | 1.0 | Initial story creation based on Epic 1.3 requirements | Bob (SM) |
| 2025-07-11 | 1.1 | Updated with detailed AC, template resolution system, and synchronous execution clarifications | Sarah (PO) |
| 2025-07-11 | 1.2 | Added gap analysis clarifications: plain text responses, comprehensive input_params, status transitions, error handling, code organization | Bob (SM) |
| 2025-07-11 | 1.3 | Marked as Approved and ready for development implementation | Bob (SM) |